<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>extrator API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>extrator</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># ----------------------------------------------------------------
# Funções para extração de seções contidas no texto obtido
# ----------------------------------------------------------------

import re
from src.classes.documentos import Secao
from src.classes.documentos import Subsecao
import copy as cp


def separar_em_termos(documento):
    &#34;&#34;&#34;
    Separa o documento em termos (palavras, números, etc.)

        @param documento: Edital lido
        @return: Lista contendo listas com os termos do documento e suas respectivas páginas
    &#34;&#34;&#34;
    termos = []

    for pagina, texto in documento.items():
        termos_aux = texto.split()

        for termo in termos_aux:
            termos.append([termo, pagina])

    return termos


def encontrar_itens_numerados(string):
    &#34;&#34;&#34;
    Encontra os itens numerados que constam numa string (Exemplo: 1.1, 1.1.2, 2.3.4.2, 2020, 2019., 00, 0., etc.)

        @param string: String contendo o texto onde os itens serão pesquisados
        @return: Lista com todos os itens encontrados
    &#34;&#34;&#34;
    #  Encontra os itens utilizando expressões regulares
    expressao_regular = re.compile(&#39;[0-9][0-9.]*&#39;)

    return expressao_regular.findall(string)


def separar_secao(secao_candidata, termo):
    &#34;&#34;&#34;
    Verifica se o texto começa com uma provável seção e a separa, se for o caso

        @param secao_candidata: Seção candidata a ser avaliada
        @param termo: Termo a ser avaliado
        @return: Uma lista com o texto separado da seção candidata e a página onde ele se encontra; ou uma lista
        vazia, se não for possível separar o termo da seção candidata
    &#34;&#34;&#34;
    indice_fim_secao = 0  # Guarda o índice onde termina a seção candidata no texto

    # Verifica se o texto inicia com a seção candidata, se não iniciar, retorna uma lista vazia indicando que
    # o termo não é uma seção candidata
    for i in range(len(secao_candidata)):
        if secao_candidata[i] != termo[0][i]:  # termo[0] = termo; termo[1] = página onde o termo se encontra
            return []
        else:
            indice_fim_secao += 1

    # A seção candidata tem que terminar com &#39;.&#39;
    if secao_candidata[indice_fim_secao - 1] == &#39;.&#39;:
        texto_depois_da_secao = &#39;&#39;

        # Obtém o texto que estava grudado na seção candidata
        for i in range(indice_fim_secao, len(termo[0])):
            texto_depois_da_secao += termo[0][i]  # termo[0] = termo; termo[1] = página onde o termo se encontra

        # Retorna um novo termo formado pelo texto que estava grudado na seção candidata e a página onde ele se encontra
        return [texto_depois_da_secao, termo[1]]
    else:
        return []


def encontrar_secoes_candidatas(termos):
    &#34;&#34;&#34;
    Encontra os termos que podem representar uma seção.
    &gt;&gt; Obs.: Esta função causa um efeito colateral, pois a lista de termos pode ser alterada caso possua um termo que
    tem uma seção candidata com um texto grudado nela (ex.: 2.1.termo_grudado).

        @param termos: Todos os termos encontrados no documento
        @return: Lista contendo os termos que podem representar uma seção
    &#34;&#34;&#34;
    secoes_candidatas = []
    inserir_em_termos = []  # Armazena os textos que estavam grudados no final de uma seção candidata

    for indice, t in enumerate(termos):  # t[0] = Termo; t[1] = Página do documento onde o termo se encontra
        validado = False
        # Se tiver um ou mais itens numerados no termo, receberá uma lista de strings contendo estes itens, como por
        # exemplo: [&#39;1.1&#39;, &#39;1.1.2&#39;]; [&#39;2.3.4.2&#39;]; [&#39;2020&#39;, &#39;2019.&#39;, &#39;00&#39;, &#39;0.&#39;]; etc.
        secao_cand = encontrar_itens_numerados(t[0])

        # Só será uma seção candidata se o termo possuir somente um item numerado
        if len(secao_cand) == 1:
            # Obs.: Não permite seções candidatas começando com &#39;0&#39; e verifica se tem texto grudado com a seção
            if secao_cand[0][0] != &#39;0&#39; and secao_cand[0] == t[0]:  # termo[0] = termo; termo[1] = pág onde o termo está
                validado = True
            else:
                texto_separado = separar_secao(secao_cand[0], t)

                # Se havia texto grudado na seção candidata e esta é válida
                if texto_separado:
                    # Guarda o novo termo para inserir na lista de termos do documento logo após a seção candidata
                    inserir_em_termos.append([indice + 1, texto_separado])

                    # &gt;&gt;AVISO: A atribuição abaixo causa um efeito colateral, pois a lista de termos será alterada!!!
                    # Altera o termo da lista de termos com a seção candidata sem o termo grudado
                    termos[indice] = [secao_cand[0], t[1]]  # t[1] = página onde a seção se encontra

                    validado = True

        if validado:
            secoes_candidatas.append(termos[indice])

    # Caso existam, inserem os novos termos na lista de termos
    for termo_novo in inserir_em_termos:
        # termo_novo[0] = Índice da lista de termos onde o novo termo será inserido
        # termo_novo[1] = Lista contendo o termo e a página onde ele se encontra no documento
        termos.insert(termo_novo[0], termo_novo[1])

    return secoes_candidatas


def validar_secao_repescagem(secoes_candidatas, secao_verificar, ind_prox_secao):
    &#34;&#34;&#34;
    Faz uma repescagem e tenta validar uma seção candidata caso ela não tenha se encaixado em nenhum padrão anterior

        @param secoes_candidatas: Seções que estão sendo validadas
        @param secao_verificar: Seção que será verificada
        @param ind_prox_secao: Índice da seção posterior à que está sendo verificada
        @return: &#39;True&#39; se a seção for válida, &#39;False&#39; caso contrário
    &#34;&#34;&#34;
    secao_valida = False
    quantidade_verificacoes = 0
    quantidade_maxima_verificacoes = 30

    for i in range(ind_prox_secao, len(secoes_candidatas)):
        # secoes_candidatas[i][0] = Termo; secoes_candidatas[i][1] = Página do documento onde o termo se encontra
        prox_secao = secoes_candidatas[i][0].split(&#39;.&#39;)

        # Trata os casos de seções candidatas que não possuem &#39;.&#39;, exemplo: 1, 2, 3
        # Obs.: Para não dar erro de índice inexistente
        if len(prox_secao) == 1:
            prox_secao.append(&#39;&#39;)

        # Trata o caso de um início de seção que teve a sua sequência interrompida por números que não são
        # seções válidas. Ex.: [6.9, 7.1, 5, 80, 7.2, 7.3, 7.4]. Neste caso, a 7.1 será validada porque encontrará
        # como uma das próximas seções a seção 7.2, mesmo depois dos números 5 e 80
        # Obs.: secao_verificar[0] = seção; secao_verificar[1] = subseção. O mesmo vale para &#39;prox_secao&#39;
        if secao_verificar[0] == prox_secao[0] and secao_verificar[1] == &#39;1&#39; and prox_secao[1] == &#39;2&#39;:
            secao_valida = True
            break
        elif quantidade_verificacoes &gt; quantidade_maxima_verificacoes:
            break

        quantidade_verificacoes += 1

    return secao_valida


def extrair_secoes(secoes_candidatas):
    &#34;&#34;&#34;
    Valida e extrai as seções

        @param secoes_candidatas: Seções candidatas que serão validadas e utilizadas para extrair as seções
        @return: Lista com as seções extraídas
    &#34;&#34;&#34;
    secoes_extraidas = []

    # Permitem validar a partir da seção que está na posição 0 da lista de seções candidatas
    ultima_secao_validada = [&#39;-1&#39;, &#39;&#39;]

    for i in range(len(secoes_candidatas) - 1):
        sessao_valida = False

        # Se a seção candidata tiver &#39;.&#39;, vai retornar uma lista com a seçao e a subseção:
        # =&gt; Ex.: para &#39;2.1&#39; retorna [&#39;2&#39;, &#39;1&#39;]; já se for &#39;2.&#39; retorna [&#39;2&#39;, &#39;&#39;]
        secao_corrente = secoes_candidatas[i][0].split(&#39;.&#39;)
        proxima_secao = secoes_candidatas[i+1][0].split(&#39;.&#39;)

        # Trata os casos de seções candidatas que não possuem &#39;.&#39;, exemplo: 1, 2, 3, 20
        # Obs.: Para não dar erro de índice inexistente
        if len(secao_corrente) == 1:
            secao_corrente.append(&#39;&#39;)

        if len(proxima_secao) == 1:
            proxima_secao.append(&#39;&#39;)

        # Verifica comparando com a seção corrente ou com a próxima seção. Deve cumprir requisitos que
        # indicam que a seção que está sendo verificada é uma nova seção ou sequência de uma seção anterior
        # - Exemplos de novas seções: 1.; 1.1; 2.1 | Exemplos de próximas seções: 1.2; 1.3; 2.4; 2.5
        if secao_corrente[0] == ultima_secao_validada[0]:

            # Para evitar erro nas conversões para &#39;int&#39;
            if secao_corrente[1] != &#39;&#39; and ultima_secao_validada[1] != &#39;&#39;:

                # Verifica se é sequência da última seção validada ou se é o segundo nível de uma seção.
                # Exemplo de seções com o mesmo segundo nível: [&#39;1.1.1&#39;, &#39;1.1.2&#39;, &#39;1.1.3&#39;] todas derivam da &#39;1.1.&#39;
                if int(secao_corrente[1]) - 1 == int(ultima_secao_validada[1]) or \
                        secao_corrente[1] == ultima_secao_validada[1]:
                    sessao_valida = True

            # Trata os casos de seções que são sequências de seções terminadas com &#39;.&#39; ou quando acontece um
            # reinício de seção após uma seção &#39;1&#39;. Exemplo: [&#39;1.&#39;, &#39;1.1&#39;, &#39;1.3&#39;, &#39;1.&#39;(reinício), &#39;1.1&#39;]
            elif secao_corrente[1] == &#39;1&#39; or secao_corrente[0] == &#39;1&#39;:
                sessao_valida = True

        # Verifica se é um início de seção do tipo &#39;x.&#39;, exemplos: 1.; 2.; 10.
        elif secao_corrente[0] == proxima_secao[0] and secao_corrente[1] == &#39;&#39; and proxima_secao[1] == &#39;1&#39;:
            sessao_valida = True

        # Verifica se é um início de seção do tipo &#39;x.1&#39;, exemplos: 1.1; 2.1; 10.1
        elif secao_corrente[0] == proxima_secao[0] and secao_corrente[1] == &#39;1&#39; and proxima_secao[1] == &#39;2&#39;:
            sessao_valida = True

        # Verifica, se mesmo não se encaixando com as regras anteriores, é um início de seção do tipo &#39;x.1&#39;
        elif secao_corrente[1] == &#39;1&#39;:
            sessao_valida = validar_secao_repescagem(secoes_candidatas, secao_corrente, i + 1)

        if sessao_valida:
            secoes_extraidas.append(secoes_candidatas[i])
            ultima_secao_validada = secao_corrente

    # Assume que a última seção candidata é válida, pois não tem como validar com o mesmo nível de certeza das outras
    if secoes_candidatas:
        secoes_extraidas.append(secoes_candidatas[-1])

    return secoes_extraidas


def extrair_descricao(secao_inicial, secao_final, termos):
    &#34;&#34;&#34;
    Extrai a descrição entre duas seções/subseções

        @param secao_inicial: A seção/subseção a qual a descrição pertence
        @param secao_final: A seção/subseção que indicará o fim da descrição
        @param termos: Texto de onde a descrição será extraída
        @return: Descrição extraida do texto
    &#34;&#34;&#34;
    qtd_maxima_termos_ultima_secao = 300  # Quantos termos serão lidos caso seja a última seção do documento
    descricao = []

    # Pega o índice da primeira ocorrência da seção inicial no texto
    index_secao_inicial = termos.index(secao_inicial)

    index_secao_final = []

    # Se a seção não é a última do documento
    if secao_final != &#39;-1.&#39;:
        # Caso no texto existam mais de uma ocorrência da seção final, pega os índices das primeiras
        # &#39;quantidade_maxima_termos_lidos&#39; ocorrências
        if termos.count(secao_final) &gt; 1:
            quantidade_termos_lidos = 0
            quantidade_maxima_termos_lidos = 300

            # Começa na primeira ocorrência e vai até o final da lista de termos ou até atingir o limite máximo
            # de termos lidos
            for i in range(termos.index(secao_final), len(termos)):
                if secao_final == termos[i]:
                    index_secao_final.append(i)

                quantidade_termos_lidos += 1

                if quantidade_termos_lidos &gt; quantidade_maxima_termos_lidos:
                    break
        else:
            index_secao_final.append(termos.index(secao_final))
    else:
        # Escolhe quantos termos serão lidos caso a seção/subseção seja a última do edital
        index_secao_final.append(min(len(termos), qtd_maxima_termos_ultima_secao))

    # Pega todos os termos entre a primeira ocorrência da seção inicial e a última ocorrência da seção final
    for i in range(index_secao_inicial + 1, max(index_secao_final)):
        descricao.append(termos[i][0])  # termos[i][0] = Termo; termos[i][1] = Pág do documento onde o termo se encontra

    return &#39; &#39;.join(descricao)


def preencher_descricao(secoes_extraidas, termos_no_doc):
    &#34;&#34;&#34;
    Preenche as descrições das seções extraídas com base no documento

        @param secoes_extraidas: Seções extraídas que receberão as descrições
        @param termos_no_doc: Termos extraídos do Edital de compras lido
    &#34;&#34;&#34;
    secao_inicial = None

    for i in range(len(secoes_extraidas) - 1):
        secao_inicial = secoes_extraidas[i]
        secao_final = secoes_extraidas[i+1]

        # &gt;&gt;AVISO: A inserção abaixo causa um efeito colateral:
        # Os elementos da lista de seções candidatas serão alterados!!!
        secao_inicial.append(extrair_descricao(secao_inicial, secao_final, termos_no_doc))

    if secao_inicial:
        # Preenche a última seção da lista de seções extraídas
        secoes_extraidas[-1].append(extrair_descricao(secao_inicial, &#39;-1.&#39;, termos_no_doc))
    elif len(secoes_extraidas) == 1:
        secoes_extraidas[0].append(&#39;&#39;)  # Evita erro de índice na função &#34;agrupar_secoes&#34;


def agrupar_secoes(secoes_extraidas):
    &#34;&#34;&#34;
    Agrupa as seções e cria um objeto para cada seção agrupada

        @param secoes_extraidas: Seções que foram extraídas do documento
        @return: Lista contendo as seções agrupadas
    &#34;&#34;&#34;
    # Permite agrupar a partir da seção que está na posição 0 da primeira lista de seções extraídas
    ultima_secao_lida = &#39;0&#39;

    secao = None
    secoes_agrupadas = []

    for s in secoes_extraidas:
        # Se a seção candidata tiver &#39;.&#39;, vai retornar uma lista com a seçao e a subseção:
        # =&gt; Ex.: para &#39;2.1&#39; retorna [&#39;2&#39;, &#39;1&#39;]; já se for &#39;2.&#39; retorna [&#39;2&#39;, &#39;&#39;]
        # Obs.: secao_atual[0] guardará a seção para ser comparada no &#39;if&#39; a seguir
        secao_atual = s[0].split(&#39;.&#39;)

        # Se for uma nova seção, instancia e inicializa um objeto para esta seção
        if secao_atual[0] != ultima_secao_lida:
            if ultima_secao_lida != &#39;0&#39;:
                secoes_agrupadas.append(cp.deepcopy(secao))

            ultima_secao_lida = secao_atual[0]
            secao = Secao(s[0] + &#39; &#39;)  # Para evitar erro na hora de criar o mapeamento ao salvar no Elasticsearch
            secao.titulo = s[2]
            secao.inserir_pagina(s[1])
        else:  # Senão, atualiza a lista de subseções do objeto que contém a seção
            subsecao = Subsecao(s[0] + &#39; &#39;)  # Para evitar erro na hora de criar o mapeamento ao salvar no Elasticsearch
            subsecao.descricao = s[2]
            subsecao.pagina = s[1]
            secao.inserir_subsecao(cp.deepcopy(subsecao))

            if s[1] not in secao.paginas:
                secao.inserir_pagina(s[1])

    return secoes_agrupadas</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="extrator.agrupar_secoes"><code class="name flex">
<span>def <span class="ident">agrupar_secoes</span></span>(<span>secoes_extraidas)</span>
</code></dt>
<dd>
<div class="desc"><p>Agrupa as seções e cria um objeto para cada seção agrupada</p>
<pre><code>@param secoes_extraidas: Seções que foram extraídas do documento
@return: Lista contendo as seções agrupadas
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def agrupar_secoes(secoes_extraidas):
    &#34;&#34;&#34;
    Agrupa as seções e cria um objeto para cada seção agrupada

        @param secoes_extraidas: Seções que foram extraídas do documento
        @return: Lista contendo as seções agrupadas
    &#34;&#34;&#34;
    # Permite agrupar a partir da seção que está na posição 0 da primeira lista de seções extraídas
    ultima_secao_lida = &#39;0&#39;

    secao = None
    secoes_agrupadas = []

    for s in secoes_extraidas:
        # Se a seção candidata tiver &#39;.&#39;, vai retornar uma lista com a seçao e a subseção:
        # =&gt; Ex.: para &#39;2.1&#39; retorna [&#39;2&#39;, &#39;1&#39;]; já se for &#39;2.&#39; retorna [&#39;2&#39;, &#39;&#39;]
        # Obs.: secao_atual[0] guardará a seção para ser comparada no &#39;if&#39; a seguir
        secao_atual = s[0].split(&#39;.&#39;)

        # Se for uma nova seção, instancia e inicializa um objeto para esta seção
        if secao_atual[0] != ultima_secao_lida:
            if ultima_secao_lida != &#39;0&#39;:
                secoes_agrupadas.append(cp.deepcopy(secao))

            ultima_secao_lida = secao_atual[0]
            secao = Secao(s[0] + &#39; &#39;)  # Para evitar erro na hora de criar o mapeamento ao salvar no Elasticsearch
            secao.titulo = s[2]
            secao.inserir_pagina(s[1])
        else:  # Senão, atualiza a lista de subseções do objeto que contém a seção
            subsecao = Subsecao(s[0] + &#39; &#39;)  # Para evitar erro na hora de criar o mapeamento ao salvar no Elasticsearch
            subsecao.descricao = s[2]
            subsecao.pagina = s[1]
            secao.inserir_subsecao(cp.deepcopy(subsecao))

            if s[1] not in secao.paginas:
                secao.inserir_pagina(s[1])

    return secoes_agrupadas</code></pre>
</details>
</dd>
<dt id="extrator.encontrar_itens_numerados"><code class="name flex">
<span>def <span class="ident">encontrar_itens_numerados</span></span>(<span>string)</span>
</code></dt>
<dd>
<div class="desc"><p>Encontra os itens numerados que constam numa string (Exemplo: 1.1, 1.1.2, 2.3.4.2, 2020, 2019., 00, 0., etc.)</p>
<pre><code>@param string: String contendo o texto onde os itens serão pesquisados
@return: Lista com todos os itens encontrados
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encontrar_itens_numerados(string):
    &#34;&#34;&#34;
    Encontra os itens numerados que constam numa string (Exemplo: 1.1, 1.1.2, 2.3.4.2, 2020, 2019., 00, 0., etc.)

        @param string: String contendo o texto onde os itens serão pesquisados
        @return: Lista com todos os itens encontrados
    &#34;&#34;&#34;
    #  Encontra os itens utilizando expressões regulares
    expressao_regular = re.compile(&#39;[0-9][0-9.]*&#39;)

    return expressao_regular.findall(string)</code></pre>
</details>
</dd>
<dt id="extrator.encontrar_secoes_candidatas"><code class="name flex">
<span>def <span class="ident">encontrar_secoes_candidatas</span></span>(<span>termos)</span>
</code></dt>
<dd>
<div class="desc"><p>Encontra os termos que podem representar uma seção.</p>
<blockquote>
<blockquote>
<p>Obs.: Esta função causa um efeito colateral, pois a lista de termos pode ser alterada caso possua um termo que
tem uma seção candidata com um texto grudado nela (ex.: 2.1.termo_grudado).</p>
</blockquote>
</blockquote>
<pre><code>@param termos: Todos os termos encontrados no documento
@return: Lista contendo os termos que podem representar uma seção
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encontrar_secoes_candidatas(termos):
    &#34;&#34;&#34;
    Encontra os termos que podem representar uma seção.
    &gt;&gt; Obs.: Esta função causa um efeito colateral, pois a lista de termos pode ser alterada caso possua um termo que
    tem uma seção candidata com um texto grudado nela (ex.: 2.1.termo_grudado).

        @param termos: Todos os termos encontrados no documento
        @return: Lista contendo os termos que podem representar uma seção
    &#34;&#34;&#34;
    secoes_candidatas = []
    inserir_em_termos = []  # Armazena os textos que estavam grudados no final de uma seção candidata

    for indice, t in enumerate(termos):  # t[0] = Termo; t[1] = Página do documento onde o termo se encontra
        validado = False
        # Se tiver um ou mais itens numerados no termo, receberá uma lista de strings contendo estes itens, como por
        # exemplo: [&#39;1.1&#39;, &#39;1.1.2&#39;]; [&#39;2.3.4.2&#39;]; [&#39;2020&#39;, &#39;2019.&#39;, &#39;00&#39;, &#39;0.&#39;]; etc.
        secao_cand = encontrar_itens_numerados(t[0])

        # Só será uma seção candidata se o termo possuir somente um item numerado
        if len(secao_cand) == 1:
            # Obs.: Não permite seções candidatas começando com &#39;0&#39; e verifica se tem texto grudado com a seção
            if secao_cand[0][0] != &#39;0&#39; and secao_cand[0] == t[0]:  # termo[0] = termo; termo[1] = pág onde o termo está
                validado = True
            else:
                texto_separado = separar_secao(secao_cand[0], t)

                # Se havia texto grudado na seção candidata e esta é válida
                if texto_separado:
                    # Guarda o novo termo para inserir na lista de termos do documento logo após a seção candidata
                    inserir_em_termos.append([indice + 1, texto_separado])

                    # &gt;&gt;AVISO: A atribuição abaixo causa um efeito colateral, pois a lista de termos será alterada!!!
                    # Altera o termo da lista de termos com a seção candidata sem o termo grudado
                    termos[indice] = [secao_cand[0], t[1]]  # t[1] = página onde a seção se encontra

                    validado = True

        if validado:
            secoes_candidatas.append(termos[indice])

    # Caso existam, inserem os novos termos na lista de termos
    for termo_novo in inserir_em_termos:
        # termo_novo[0] = Índice da lista de termos onde o novo termo será inserido
        # termo_novo[1] = Lista contendo o termo e a página onde ele se encontra no documento
        termos.insert(termo_novo[0], termo_novo[1])

    return secoes_candidatas</code></pre>
</details>
</dd>
<dt id="extrator.extrair_descricao"><code class="name flex">
<span>def <span class="ident">extrair_descricao</span></span>(<span>secao_inicial, secao_final, termos)</span>
</code></dt>
<dd>
<div class="desc"><p>Extrai a descrição entre duas seções/subseções</p>
<pre><code>@param secao_inicial: A seção/subseção a qual a descrição pertence
@param secao_final: A seção/subseção que indicará o fim da descrição
@param termos: Texto de onde a descrição será extraída
@return: Descrição extraida do texto
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extrair_descricao(secao_inicial, secao_final, termos):
    &#34;&#34;&#34;
    Extrai a descrição entre duas seções/subseções

        @param secao_inicial: A seção/subseção a qual a descrição pertence
        @param secao_final: A seção/subseção que indicará o fim da descrição
        @param termos: Texto de onde a descrição será extraída
        @return: Descrição extraida do texto
    &#34;&#34;&#34;
    qtd_maxima_termos_ultima_secao = 300  # Quantos termos serão lidos caso seja a última seção do documento
    descricao = []

    # Pega o índice da primeira ocorrência da seção inicial no texto
    index_secao_inicial = termos.index(secao_inicial)

    index_secao_final = []

    # Se a seção não é a última do documento
    if secao_final != &#39;-1.&#39;:
        # Caso no texto existam mais de uma ocorrência da seção final, pega os índices das primeiras
        # &#39;quantidade_maxima_termos_lidos&#39; ocorrências
        if termos.count(secao_final) &gt; 1:
            quantidade_termos_lidos = 0
            quantidade_maxima_termos_lidos = 300

            # Começa na primeira ocorrência e vai até o final da lista de termos ou até atingir o limite máximo
            # de termos lidos
            for i in range(termos.index(secao_final), len(termos)):
                if secao_final == termos[i]:
                    index_secao_final.append(i)

                quantidade_termos_lidos += 1

                if quantidade_termos_lidos &gt; quantidade_maxima_termos_lidos:
                    break
        else:
            index_secao_final.append(termos.index(secao_final))
    else:
        # Escolhe quantos termos serão lidos caso a seção/subseção seja a última do edital
        index_secao_final.append(min(len(termos), qtd_maxima_termos_ultima_secao))

    # Pega todos os termos entre a primeira ocorrência da seção inicial e a última ocorrência da seção final
    for i in range(index_secao_inicial + 1, max(index_secao_final)):
        descricao.append(termos[i][0])  # termos[i][0] = Termo; termos[i][1] = Pág do documento onde o termo se encontra

    return &#39; &#39;.join(descricao)</code></pre>
</details>
</dd>
<dt id="extrator.extrair_secoes"><code class="name flex">
<span>def <span class="ident">extrair_secoes</span></span>(<span>secoes_candidatas)</span>
</code></dt>
<dd>
<div class="desc"><p>Valida e extrai as seções</p>
<pre><code>@param secoes_candidatas: Seções candidatas que serão validadas e utilizadas para extrair as seções
@return: Lista com as seções extraídas
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extrair_secoes(secoes_candidatas):
    &#34;&#34;&#34;
    Valida e extrai as seções

        @param secoes_candidatas: Seções candidatas que serão validadas e utilizadas para extrair as seções
        @return: Lista com as seções extraídas
    &#34;&#34;&#34;
    secoes_extraidas = []

    # Permitem validar a partir da seção que está na posição 0 da lista de seções candidatas
    ultima_secao_validada = [&#39;-1&#39;, &#39;&#39;]

    for i in range(len(secoes_candidatas) - 1):
        sessao_valida = False

        # Se a seção candidata tiver &#39;.&#39;, vai retornar uma lista com a seçao e a subseção:
        # =&gt; Ex.: para &#39;2.1&#39; retorna [&#39;2&#39;, &#39;1&#39;]; já se for &#39;2.&#39; retorna [&#39;2&#39;, &#39;&#39;]
        secao_corrente = secoes_candidatas[i][0].split(&#39;.&#39;)
        proxima_secao = secoes_candidatas[i+1][0].split(&#39;.&#39;)

        # Trata os casos de seções candidatas que não possuem &#39;.&#39;, exemplo: 1, 2, 3, 20
        # Obs.: Para não dar erro de índice inexistente
        if len(secao_corrente) == 1:
            secao_corrente.append(&#39;&#39;)

        if len(proxima_secao) == 1:
            proxima_secao.append(&#39;&#39;)

        # Verifica comparando com a seção corrente ou com a próxima seção. Deve cumprir requisitos que
        # indicam que a seção que está sendo verificada é uma nova seção ou sequência de uma seção anterior
        # - Exemplos de novas seções: 1.; 1.1; 2.1 | Exemplos de próximas seções: 1.2; 1.3; 2.4; 2.5
        if secao_corrente[0] == ultima_secao_validada[0]:

            # Para evitar erro nas conversões para &#39;int&#39;
            if secao_corrente[1] != &#39;&#39; and ultima_secao_validada[1] != &#39;&#39;:

                # Verifica se é sequência da última seção validada ou se é o segundo nível de uma seção.
                # Exemplo de seções com o mesmo segundo nível: [&#39;1.1.1&#39;, &#39;1.1.2&#39;, &#39;1.1.3&#39;] todas derivam da &#39;1.1.&#39;
                if int(secao_corrente[1]) - 1 == int(ultima_secao_validada[1]) or \
                        secao_corrente[1] == ultima_secao_validada[1]:
                    sessao_valida = True

            # Trata os casos de seções que são sequências de seções terminadas com &#39;.&#39; ou quando acontece um
            # reinício de seção após uma seção &#39;1&#39;. Exemplo: [&#39;1.&#39;, &#39;1.1&#39;, &#39;1.3&#39;, &#39;1.&#39;(reinício), &#39;1.1&#39;]
            elif secao_corrente[1] == &#39;1&#39; or secao_corrente[0] == &#39;1&#39;:
                sessao_valida = True

        # Verifica se é um início de seção do tipo &#39;x.&#39;, exemplos: 1.; 2.; 10.
        elif secao_corrente[0] == proxima_secao[0] and secao_corrente[1] == &#39;&#39; and proxima_secao[1] == &#39;1&#39;:
            sessao_valida = True

        # Verifica se é um início de seção do tipo &#39;x.1&#39;, exemplos: 1.1; 2.1; 10.1
        elif secao_corrente[0] == proxima_secao[0] and secao_corrente[1] == &#39;1&#39; and proxima_secao[1] == &#39;2&#39;:
            sessao_valida = True

        # Verifica, se mesmo não se encaixando com as regras anteriores, é um início de seção do tipo &#39;x.1&#39;
        elif secao_corrente[1] == &#39;1&#39;:
            sessao_valida = validar_secao_repescagem(secoes_candidatas, secao_corrente, i + 1)

        if sessao_valida:
            secoes_extraidas.append(secoes_candidatas[i])
            ultima_secao_validada = secao_corrente

    # Assume que a última seção candidata é válida, pois não tem como validar com o mesmo nível de certeza das outras
    if secoes_candidatas:
        secoes_extraidas.append(secoes_candidatas[-1])

    return secoes_extraidas</code></pre>
</details>
</dd>
<dt id="extrator.preencher_descricao"><code class="name flex">
<span>def <span class="ident">preencher_descricao</span></span>(<span>secoes_extraidas, termos_no_doc)</span>
</code></dt>
<dd>
<div class="desc"><p>Preenche as descrições das seções extraídas com base no documento</p>
<pre><code>@param secoes_extraidas: Seções extraídas que receberão as descrições
@param termos_no_doc: Termos extraídos do Edital de compras lido
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preencher_descricao(secoes_extraidas, termos_no_doc):
    &#34;&#34;&#34;
    Preenche as descrições das seções extraídas com base no documento

        @param secoes_extraidas: Seções extraídas que receberão as descrições
        @param termos_no_doc: Termos extraídos do Edital de compras lido
    &#34;&#34;&#34;
    secao_inicial = None

    for i in range(len(secoes_extraidas) - 1):
        secao_inicial = secoes_extraidas[i]
        secao_final = secoes_extraidas[i+1]

        # &gt;&gt;AVISO: A inserção abaixo causa um efeito colateral:
        # Os elementos da lista de seções candidatas serão alterados!!!
        secao_inicial.append(extrair_descricao(secao_inicial, secao_final, termos_no_doc))

    if secao_inicial:
        # Preenche a última seção da lista de seções extraídas
        secoes_extraidas[-1].append(extrair_descricao(secao_inicial, &#39;-1.&#39;, termos_no_doc))
    elif len(secoes_extraidas) == 1:
        secoes_extraidas[0].append(&#39;&#39;)  # Evita erro de índice na função &#34;agrupar_secoes&#34;</code></pre>
</details>
</dd>
<dt id="extrator.separar_em_termos"><code class="name flex">
<span>def <span class="ident">separar_em_termos</span></span>(<span>documento)</span>
</code></dt>
<dd>
<div class="desc"><p>Separa o documento em termos (palavras, números, etc.)</p>
<pre><code>@param documento: Edital lido
@return: Lista contendo listas com os termos do documento e suas respectivas páginas
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def separar_em_termos(documento):
    &#34;&#34;&#34;
    Separa o documento em termos (palavras, números, etc.)

        @param documento: Edital lido
        @return: Lista contendo listas com os termos do documento e suas respectivas páginas
    &#34;&#34;&#34;
    termos = []

    for pagina, texto in documento.items():
        termos_aux = texto.split()

        for termo in termos_aux:
            termos.append([termo, pagina])

    return termos</code></pre>
</details>
</dd>
<dt id="extrator.separar_secao"><code class="name flex">
<span>def <span class="ident">separar_secao</span></span>(<span>secao_candidata, termo)</span>
</code></dt>
<dd>
<div class="desc"><p>Verifica se o texto começa com uma provável seção e a separa, se for o caso</p>
<pre><code>@param secao_candidata: Seção candidata a ser avaliada
@param termo: Termo a ser avaliado
@return: Uma lista com o texto separado da seção candidata e a página onde ele se encontra; ou uma lista
vazia, se não for possível separar o termo da seção candidata
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def separar_secao(secao_candidata, termo):
    &#34;&#34;&#34;
    Verifica se o texto começa com uma provável seção e a separa, se for o caso

        @param secao_candidata: Seção candidata a ser avaliada
        @param termo: Termo a ser avaliado
        @return: Uma lista com o texto separado da seção candidata e a página onde ele se encontra; ou uma lista
        vazia, se não for possível separar o termo da seção candidata
    &#34;&#34;&#34;
    indice_fim_secao = 0  # Guarda o índice onde termina a seção candidata no texto

    # Verifica se o texto inicia com a seção candidata, se não iniciar, retorna uma lista vazia indicando que
    # o termo não é uma seção candidata
    for i in range(len(secao_candidata)):
        if secao_candidata[i] != termo[0][i]:  # termo[0] = termo; termo[1] = página onde o termo se encontra
            return []
        else:
            indice_fim_secao += 1

    # A seção candidata tem que terminar com &#39;.&#39;
    if secao_candidata[indice_fim_secao - 1] == &#39;.&#39;:
        texto_depois_da_secao = &#39;&#39;

        # Obtém o texto que estava grudado na seção candidata
        for i in range(indice_fim_secao, len(termo[0])):
            texto_depois_da_secao += termo[0][i]  # termo[0] = termo; termo[1] = página onde o termo se encontra

        # Retorna um novo termo formado pelo texto que estava grudado na seção candidata e a página onde ele se encontra
        return [texto_depois_da_secao, termo[1]]
    else:
        return []</code></pre>
</details>
</dd>
<dt id="extrator.validar_secao_repescagem"><code class="name flex">
<span>def <span class="ident">validar_secao_repescagem</span></span>(<span>secoes_candidatas, secao_verificar, ind_prox_secao)</span>
</code></dt>
<dd>
<div class="desc"><p>Faz uma repescagem e tenta validar uma seção candidata caso ela não tenha se encaixado em nenhum padrão anterior</p>
<pre><code>@param secoes_candidatas: Seções que estão sendo validadas
@param secao_verificar: Seção que será verificada
@param ind_prox_secao: Índice da seção posterior à que está sendo verificada
@return: 'True' se a seção for válida, 'False' caso contrário
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validar_secao_repescagem(secoes_candidatas, secao_verificar, ind_prox_secao):
    &#34;&#34;&#34;
    Faz uma repescagem e tenta validar uma seção candidata caso ela não tenha se encaixado em nenhum padrão anterior

        @param secoes_candidatas: Seções que estão sendo validadas
        @param secao_verificar: Seção que será verificada
        @param ind_prox_secao: Índice da seção posterior à que está sendo verificada
        @return: &#39;True&#39; se a seção for válida, &#39;False&#39; caso contrário
    &#34;&#34;&#34;
    secao_valida = False
    quantidade_verificacoes = 0
    quantidade_maxima_verificacoes = 30

    for i in range(ind_prox_secao, len(secoes_candidatas)):
        # secoes_candidatas[i][0] = Termo; secoes_candidatas[i][1] = Página do documento onde o termo se encontra
        prox_secao = secoes_candidatas[i][0].split(&#39;.&#39;)

        # Trata os casos de seções candidatas que não possuem &#39;.&#39;, exemplo: 1, 2, 3
        # Obs.: Para não dar erro de índice inexistente
        if len(prox_secao) == 1:
            prox_secao.append(&#39;&#39;)

        # Trata o caso de um início de seção que teve a sua sequência interrompida por números que não são
        # seções válidas. Ex.: [6.9, 7.1, 5, 80, 7.2, 7.3, 7.4]. Neste caso, a 7.1 será validada porque encontrará
        # como uma das próximas seções a seção 7.2, mesmo depois dos números 5 e 80
        # Obs.: secao_verificar[0] = seção; secao_verificar[1] = subseção. O mesmo vale para &#39;prox_secao&#39;
        if secao_verificar[0] == prox_secao[0] and secao_verificar[1] == &#39;1&#39; and prox_secao[1] == &#39;2&#39;:
            secao_valida = True
            break
        elif quantidade_verificacoes &gt; quantidade_maxima_verificacoes:
            break

        quantidade_verificacoes += 1

    return secao_valida</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="extrator.agrupar_secoes" href="#extrator.agrupar_secoes">agrupar_secoes</a></code></li>
<li><code><a title="extrator.encontrar_itens_numerados" href="#extrator.encontrar_itens_numerados">encontrar_itens_numerados</a></code></li>
<li><code><a title="extrator.encontrar_secoes_candidatas" href="#extrator.encontrar_secoes_candidatas">encontrar_secoes_candidatas</a></code></li>
<li><code><a title="extrator.extrair_descricao" href="#extrator.extrair_descricao">extrair_descricao</a></code></li>
<li><code><a title="extrator.extrair_secoes" href="#extrator.extrair_secoes">extrair_secoes</a></code></li>
<li><code><a title="extrator.preencher_descricao" href="#extrator.preencher_descricao">preencher_descricao</a></code></li>
<li><code><a title="extrator.separar_em_termos" href="#extrator.separar_em_termos">separar_em_termos</a></code></li>
<li><code><a title="extrator.separar_secao" href="#extrator.separar_secao">separar_secao</a></code></li>
<li><code><a title="extrator.validar_secao_repescagem" href="#extrator.validar_secao_repescagem">validar_secao_repescagem</a></code></li>
</ul>
</li>
</ul>
<p><a href="index.html" title="Voltar"><h3><< Voltar</h3></a></p>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
