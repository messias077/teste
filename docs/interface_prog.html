<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>interface_prog API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>interface_prog</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -----------------------------------------------------------------------------
# Interface interativa do sistema em modo texto
# Versão: 0.5.0
# -----------------------------------------------------------------------------

import os
from src.ambiente.parametros_globais import FILE_NOT_FOUND_ERROR, PERMISSION_ERROR, PREPROC_CAMINHO_ARQ_CONF
from src.ambiente.preparar_ambiente import inicializar_parametros, validar_pastas
from src.classes.persistencia.cliente import ClienteGenerico
from src.classes.persistencia.dump_arq import descarregar_conteudo
from src.classes.persistencia.serializacao import desserializar
from src.modulos.preproc.pre_processador import preparar_arquivo
from src.modulos.preproc.preproc import pre_processamento
from src.modulos.ren.conversor_jsonl_conll import converter_jsonl_conll
from src.modulos.ren.ren import ren
from src.utils.geradores import gerar_data, gerar_epoch


def imprimir_chaves(tipo_doc):
    &#34;&#34;&#34;
    Imprime as chaves correspondentes à cada tipo de documento

        @param tipo_doc: Tipo do documento para imprimir as chaves correspondentes
    &#34;&#34;&#34;
    print(
        &#34;&#34;&#34;
        ----&gt; Chaves para pesquisa &lt;----

        Escolha uma chave, copie e cole no campo &#34;Chave&#34;.
    &#34;&#34;&#34;)

    tipo = tipo_doc.upper()

    if tipo == &#34;EDITAL&#34;:
        print(
            &#34;&#34;&#34;
            ## Edital:
                Edital__nome
                Edital__codigo_arq
                Edital__codigo_lote
                Edital__dumpconteudo
                Edital__secoes.Secao__numero
                Edital__secoes.Secao__titulo
                Edital__secoes.Secao__subsecoes.Subsecao__numero
                Edital__secoes.Secao__subsecoes.Subsecao__descricao
                &#34;&#34;&#34;)
    elif tipo == &#34;DOCUMENTO&#34;:
        print(
            &#34;&#34;&#34;
            ## Documento:
                Documento__nome
                Documento__codigo_arq
                Documento__hash_md5
                Documento__tipo_arq
                Documento__extensao
                Documento__data_cadastro
                Documento__usuario_cadastrou
                Documento__cod_processamento
                Documento__codigo_lote
                Documento__nome_arq_original
                Documento__url_web
                Documento__caminho_base
                Documento__caminho_relativo
                Documento__head
                &#34;&#34;&#34;)
    elif tipo == &#34;LOTE&#34;:
        print(
            &#34;&#34;&#34;
            ## Lote:
                Lote__codigo_lote
                Lote__tipo
                Lote__tempo_inicio
                Lote__tempo_fim
                Lote__documentos_ok
                Lote__documentos_erro
                &#34;&#34;&#34;)
    elif tipo == &#34;RESULTADO&#34;:
        print(
            &#34;&#34;&#34;
            ## Resultado:
                Resultado__tipo
                Resultado__codigo_lote
                Resultado__data_resultado
                Resultado__status
                Resultado__nome_arq_original
                Resultado__tipo_arq
                Resultado__codigo_arq
                Resultado__url_web
                Resultado__usuario_cadastrou
                Resultado__data_cadastro
                Resultado__mensagens
            &#34;&#34;&#34;
        )


def cadastrar_arquivos(tipo, usuario, caminho_entrada):
    &#34;&#34;&#34;
        Faz o cadastro dos arquivos

            @param tipo: Tipo do arquivo (EDITAL, etc.)
            @param usuario: Usuário que está realizando o cadastro
            @param caminho_entrada: Caminho onde os documentos no formato PDF se encontram
    &#34;&#34;&#34;
    caminho = None

    if tipo == &#39;EDITAL&#39;:
        caminho = os.path.join(caminho_entrada, &#39;editais&#39;)

    arquivos_cadastrar = []

    # Obtém a lista de todos os arquivos que serão cadastrados
    try:
        arquivos_cadastrar = os.listdir(caminho)
    except FileNotFoundError:
        print(f&#34;\nO caminho &#39;{caminho}&#39; não existe!\n&#34;)
        exit(FILE_NOT_FOUND_ERROR)
    except PermissionError:
        print(f&#34;\nErro ao listar o caminho &#39;{caminho}&#39;. Permissão de leitura negada!\n&#34;)
        exit(PERMISSION_ERROR)

    arquivos_cadastrar.sort()

    if &#39;preproc.lock&#39; not in arquivos_cadastrar:
        qtd_arquivos_cadastrados = 0
        print(&#34;\n=&gt; Arquivos cadastrados:\n&#34;)

        for a in arquivos_cadastrar:
            if &#39;.metadados&#39; not in a and a + &#39;.metadados&#39; not in arquivos_cadastrar and a != &#39;erro&#39;:
                print(f&#34;   {a}&#34;)
                qtd_arquivos_cadastrados += 1
                preparar_arquivo(caminho, a, &#34;n/a&#34;, usuario, gerar_epoch())

        print(f&#34;\nQuantidade de arquivos cadastrados: {qtd_arquivos_cadastrados}&#34;)
    else:
        print(f&#34;\nERRO: A pasta &#39;{caminho_entrada}&#39; está bloqueada pela rotina de pre-processamento. Aguarde a rotina &#34;
              f&#34;terminar e tente novamente!&#34;)


def imprimir_documento(doc_obj, mensagem):
    &#34;&#34;&#34;
    Imprime um documento

        @param doc_obj: Documento que será impresso
        @param mensagem: Mensagem referente ao documento que será impresso
    &#34;&#34;&#34;
    print(mensagem)
    print(len(mensagem) * &#39;-&#39;, end=&#39;&#39;)
    print(&#39;\n&#39;)

    if &#39;EDITAL&#39; in mensagem:
        print(f&#39; &gt; Nome do documento.....: {doc_obj.nome}\n&#39;)
        print(f&#39; &gt; Código do arquivo.....: {doc_obj.codigo_arq}\n&#39;)
        print(f&#39; &gt; Código do lote........: {doc_obj.codigo_lote}\n&#39;)
        print(f&#39; &gt; Dump do conteúdo......:\n&#39;)
        for n, p in enumerate(doc_obj.dumpconteudo):
            print(f&#34;  - Pag. {n+1}: {p}&#34;)

        for s in doc_obj.secoes:
            print(f&#39;\n# Seção: {s.numero} - Pág(s) {s.paginas}: {s.titulo}&#39;)

            for sb in s.subsecoes:
                print(f&#39;{sb.numero}: {sb.descricao}&#39;)
    elif &#39;DOCUMENTO&#39; in mensagem:
        print(f&#34;Nome do arquivo...........: {doc_obj.nome}&#34;)
        print(f&#34;Código do arquivo.........: {doc_obj.codigo_arq}&#34;)
        print(f&#34;Hash MD5..................: {doc_obj.hash_md5}&#34;)
        print(f&#34;Tipo......................: {doc_obj.tipo_arq}&#34;)
        print(f&#34;Extensao..................: {doc_obj.extensao}&#34;)
        print(f&#34;Data Cadastro epoch.......: {doc_obj.data_cadastro}, tipo: {type(doc_obj.data_cadastro)}&#34;)
        print(f&#34;Data Cadastro normal......: {gerar_data(doc_obj.data_cadastro, &#39;%d/%m/%Y %H:%M:%Shs&#39;)}&#34;)
        print(f&#34;Usuário que cadastrou.....: {doc_obj.usuario_cadastrou}&#34;)
        print(f&#34;Código Processamento......: {doc_obj.cod_processamento}&#34;)
        print(f&#34;Lote......................: {doc_obj.codigo_lote}&#34;)
        print(f&#34;Nome do arquivo original..: {doc_obj.nome_arq_original}&#34;)
        print(f&#34;URL WEB...................: {doc_obj.url_web}&#34;)
        print(f&#34;Caminho Base..............: {doc_obj.caminho_base}&#34;)
        print(f&#34;Caminho Relativo..........: {doc_obj.caminho_relativo}&#34;)
        print(f&#34;Head......................: {len(doc_obj.head)} páginas&#34;)
        for p, h in enumerate(doc_obj.head):
            print(f&#34;  - Pag. {p+1}: {h}&#34;)
    elif &#39;LOTE&#39; in mensagem:
        print(f&#34;codigo....................: {doc_obj.codigo_lote}&#34;)
        print(f&#34;tipo......................: {doc_obj.tipo}&#34;)
        print(f&#34;tempo_inicio..............: {doc_obj.tempo_inicio}&#34;)
        print(f&#34;tempo_fim.................: {doc_obj.tempo_fim}&#34;)
        print(f&#34;documentos_ok.............: {doc_obj.documentos_ok}&#34;)
        print(f&#34;documentos_erro...........: {doc_obj.documentos_erro}&#34;)
        print(f&#34;Estatísticas..............: {doc_obj.obter_estatisticas()}&#34;)
    elif &#39;RESULTADO&#39; in mensagem:
        print(f&#34;Tipo do resultado.........: {doc_obj.tipo}&#34;)
        print(f&#34;Código do lote............: {doc_obj.codigo_lote}&#34;)
        print(f&#34;Data epoch................: {doc_obj.data_resultado}, tipo: {type(doc_obj.data_resultado)}&#34;)
        print(f&#34;Data normal...............: {gerar_data(doc_obj.data_resultado, &#39;%d/%m/%Y %H:%M:%Shs&#39;)}&#34;)
        print(f&#34;Status....................: {doc_obj.status}&#34;)
        print(f&#34;Nome do arquivo original..: {doc_obj.nome_arq_original}&#34;)
        print(f&#34;Tipo......................: {doc_obj.tipo_arq}&#34;)
        print(f&#34;Código do arquivo.........: {doc_obj.codigo_arq}&#34;)
        print(f&#34;URL WEB...................: {doc_obj.url_web}&#34;)
        print(f&#34;Usuário que cadastrou.....: {doc_obj.usuario_cadastrou}&#34;)
        print(f&#34;Data Cadastro normal......: {gerar_data(doc_obj.data_cadastro, &#39;%d/%m/%Y %H:%M:%Shs&#39;)}&#34;)
        print(f&#34;Mensagens.................: {len(doc_obj.mensagens)} mensagens&#34;)
        for n, m in enumerate(doc_obj.mensagens):
            print(f&#34;  - Msg. {n+1}: {m}&#34;)


def listar_documentos_impressao(tipo, docs_json, caminho_dump):
    &#34;&#34;&#34;
    Lista os documentos que poderão ser impressos

        @param tipo: Tipo do documento
        @param docs_json: Documento canditato à impressão
        @param caminho_dump: Caminho para geração do dump do edital, caso seja necessário
    &#34;&#34;&#34;
    seq = 0
    tam = len(list(docs_json))
    ler_doc = True
    objeto_desserializado = None
    print(f&#34;\n    ## Qtd de documentos retornados: {tam}&#34;)

    while seq &lt; tam:
        if ler_doc:
            objeto_desserializado = desserializar(docs_json[seq])
            ler_doc = False  # Só voltará ser &#39;True&#39; se a opção escolhida for válida
            seq += 1

        print(f&#34;\n    &gt;&gt; Doc. {seq}/{tam}&#34;)

        if tipo == &#39;EDITAL&#39; or tipo == &#39;DOCUMENTO&#39;:
            print(f&#34;        -&gt; Nome do documento: {objeto_desserializado.codigo_arq}&#34;)
        elif tipo == &#39;LOTE&#39;:
            print(f&#34;        -&gt; Código do lote: {objeto_desserializado.codigo}&#34;)
        elif tipo == &#39;RESULTADO&#39;:
            print(f&#34;        -&gt; Tipo do resultado: {objeto_desserializado.tipo}&#34;)

        r = input(&#34;   \n           Deseja imprimir (S=Sim / N=Não / V=Navegar / X=Sair)?: &#34;).upper()

        if r == &#39;S&#39;:
            if tipo == &#39;EDITAL&#39;:
                ri = input(&#34;   \n           Imprimir onde (T=Tela / A=Arquivo)?: &#34;).upper()

                if ri == &#39;T&#39;:
                    imprimir_documento(objeto_desserializado, f&#34;\n\n ** Dados extraídos - {tipo} **&#34;)
                    ler_doc = True
                elif ri == &#39;A&#39;:
                    tipo_dump = &#34;&#34;

                    print(
                        &#34;&#34;&#34;
                        &gt; Tipos de dump:\n
                          EDITAL - Edital completo com as seções separadas
                          SECOES - Somenteas seções do edital
                          CONTEUDO - Edital completo sem as seções separadas
                          TODOS - Faz o dump de todos os tipos
                        &#34;&#34;&#34;
                    )

                    while tipo_dump not in [&#39;EDITAL&#39;, &#39;SECOES&#39;, &#39;CONTEUDO&#39;, &#39;TODOS&#39;, &#39;X&#39;]:
                        tipo_dump = input(&#34;           Escolha um tipo (X=Sair): &#34;).upper()

                    if tipo_dump != &#39;X&#39;:
                        if tipo_dump != &#39;TODOS&#39;:
                            lst_tipo_dump = [tipo_dump]
                        else:
                            lst_tipo_dump = [&#39;EDITAL&#39;, &#39;SECOES&#39;, &#39;CONTEUDO&#39;]

                        for t in lst_tipo_dump:
                            nome_arquivo = os.path.join(caminho_dump, objeto_desserializado.codigo_arq.split(&#39;.&#39;)[0] +
                                                        &#39;_&#39; + t + &#39;.txt&#39;)

                            descarregar_conteudo(objeto_desserializado, t, nome_arquivo)
                            print(f&#34;\n           Salvo como &#39;{nome_arquivo}&#39;&#34;)

                        ler_doc = True
                else:
                    print(&#34;\n           Opção inválida!&#34;)
            else:
                imprimir_documento(objeto_desserializado, f&#34;\n\n ** Dados extraídos - {tipo} **&#34;)
                ler_doc = True
        elif r == &#39;N&#39;:
            ler_doc = True
        elif r == &#39;V&#39;:
            while True:
                ri = input(f&#34;\n        - Digite o no. do documento (1-{tam} / 0=Voltar): &#34;)

                try:
                    n = int(ri)
                except ValueError:
                    print(&#34;\n          Digite um número!&#34;)
                    continue

                if 1 &lt;= n &lt;= tam:
                    seq = n - 1
                    ler_doc = True
                    break
                elif n == 0:
                    break
                else:
                    print(f&#34;\n          O número digitado está fora da faixa (1 a {tam})!&#34;)
        elif r == &#39;X&#39;:
            break
        else:
            print(&#34;\n       Opção incorreta!&#34;)

    if tam &gt; 0 and (seq == tam):
        print(&#34;\n       *** Fim da lista! ***&#34;)


def ler_dados_bd(tipo, opcao, chave, valor, caminho_dump):
    &#34;&#34;&#34;
    Ler os documentos no banco de dados

        @param tipo: Tipo do documento
        @param opcao: Opção de base de dados capturada do menu principal
        @param chave: Chave para a busca do documento
        @param valor: Valor da chave para busca do documento
        @param caminho_dump: Caminho para geração do dump do edital, caso seja necessário
    &#34;&#34;&#34;
    docs_json = None

    if tipo == &#39;EDITAL&#39;:
        banco_mongo = &#39;db_documentos&#39;
        colecao_mongo = &#39;col_editais&#39;

        if opcao == &#39;3&#39;:
            c_mongo = ClienteGenerico(&#39;MongoDB&#39;, &#39;localhost&#39;, 2717, banco_mongo)
            doc_mongo_js = c_mongo.buscar_todos(colecao_mongo, chave, valor)
            c_mongo.fechar_conexao()
            docs_json = list(doc_mongo_js)
    elif tipo == &#39;DOCUMENTO&#39;:
        c_mongo_meta = ClienteGenerico(&#39;MongoDB&#39;, &#39;localhost&#39;, 2717, &#39;db_metadados&#39;)
        doc_metadados_js = c_mongo_meta.buscar_todos(&#39;col_metadados_docs&#39;, chave, valor)
        c_mongo_meta.fechar_conexao()
        docs_json = list(doc_metadados_js)
    elif tipo == &#39;LOTE&#39;:
        c_mongo_lote = ClienteGenerico(&#39;MongoDB&#39;, &#39;localhost&#39;, 2717, &#39;db_metadados&#39;)
        doc_lotes_js = c_mongo_lote.buscar_todos(&#39;col_metadados_lotes&#39;, chave, valor)
        c_mongo_lote.fechar_conexao()
        docs_json = list(doc_lotes_js)
    elif tipo == &#39;RESULTADO&#39;:
        c_mongo_resultado = ClienteGenerico(&#39;MongoDB&#39;, &#39;localhost&#39;, 2717, &#39;db_metadados&#39;)
        doc_resultados_js = c_mongo_resultado.buscar_todos(&#39;col_metadados_resultados&#39;, chave, valor)
        c_mongo_resultado.fechar_conexao()
        docs_json = list(doc_resultados_js)
    else:
        print(f&#34;\nO tipo de documento &#39;{tipo}&#39; não está cadastrado!&#34;)
        return

    listar_documentos_impressao(tipo, docs_json, caminho_dump)


def menu():
    &#34;&#34;&#34;
    Menu principal do sistema
    &#34;&#34;&#34;
    # Obtém o caminho do arquivo de configuração para montar o caminho completo
    caminho_arquivo_configuracao = PREPROC_CAMINHO_ARQ_CONF
    nome_arquivo_configuracao = &#39;param_preproc.conf&#39;
    arq_conf = os.path.join(caminho_arquivo_configuracao, nome_arquivo_configuracao)

    conf = inicializar_parametros(&#39;preproc&#39;, arq_conf)

    # Obtém alguns parâmetros de configuração do módulo
    parametros = {&#39;caminho_arq_conf&#39;: arq_conf,
                  &#39;p_caminho_entrada&#39;: conf.obter_valor_parametro(&#39;p_caminho_entrada&#39;),
                  &#39;p_caminho_dumps&#39;: conf.obter_valor_parametro(&#39;p_caminho_dumps&#39;)}

    validar_pastas(parametros)

    while True:
        print(&#39;\n***************( INTERFACE DO PROTÓTIPO - MODO TEXTO )**************\n&#39;)
        print(&#39;                      &gt;&gt; MENU &lt;&lt;\n&#39;)
        print(&#39;             1 - Cadastrar editais&#39;)
        print(&#39;             2 - Pré-Processar&#39;)
        print(&#39;             3 - Buscar editais (MongoDB)&#39;)
        print(&#39;             4 - Construir Dataset&#39;)
        print(&#39;             5 - Converter JSONL para CONLL&#39;)
        print(&#39;\n********************************************************************&#39;)
        op = input(&#34;Escolha a opção (Sair =&gt; 0): &#34;)

        if op == &#39;1&#39;:
            cadastrar_arquivos(&#39;EDITAL&#39;, &#39;SISTEMA&#39;, parametros[&#39;p_caminho_entrada&#39;])
        elif op == &#39;2&#39;:
            pre_processamento()
        elif op == &#39;3&#39;:
            print(&#34;\nInforme os parâmetros abaixo:\n&#34;)
            tipo_doc = input(&#34;  --Tipo (EDITAL, DOCUMENTO, LOTE ou RESULTADO)...: &#34;).upper()

            while tipo_doc not in [&#34;EDITAL&#34;, &#34;DOCUMENTO&#34;, &#34;LOTE&#34;, &#34;RESULTADO&#34;, &#34;X&#34;]:
                print(f&#34;\n     O tipo de documento &#39;{tipo_doc}&#39; não existe!\n&#34;)
                tipo_doc = input(&#34;  --Tipo (EDITAL, DOCUMENTO, LOTE ou RESULTADO) |  X=Sair...: &#34;).upper()

            if tipo_doc != &#39;X&#39;:
                chave_doc = &#39;*&#39;

                while chave_doc == &#39;*&#39;:
                    chave_doc = input(&#39;  --Chave (* = Listas as opções)..................: &#39;)

                    if chave_doc == &#39;*&#39;:
                        imprimir_chaves(tipo_doc)
                    else:
                        break

                while True:
                    print(f&#34;\n  ***  Pesquisando no &#39;MongoDB&#39; pela chave: &#39;{chave_doc}&#39;  ***\n&#34;)

                    valor_chave = input(&#39;    --Valor (X=Sair)..: &#39;)

                    if valor_chave.upper() == &#39;X&#39;:
                        break

                    ler_dados_bd(tipo_doc.upper(), op, chave_doc, valor_chave, parametros[&#39;p_caminho_dumps&#39;])
        elif op == &#39;4&#39;:
            gerar_estatisticas = False
            gerar_estatisticas_str = &#39;n&#39;
            organizar_em_pastas = True
            organizar_em_pastas_str = &#39;n&#39;
            qtd_sents = 0
            reprocessar = False
            retirar_sentencas_similares = False
            retirar_sentencas_similares_str = &#39;n&#39;
            escopo_global_sentencas = True
            escopo_global_sentencas_str = &#39;s&#39;

            codproc = input(&#34;\nDigite o código de processamento (ner, classificacao ou classificacao_label): &#34;)

            if codproc == &#39;ner&#39;:
                qtd_sents = int(input(&#34;Digite a quantidade de sentenças por arquivo: &#34;))
                gerar_estatisticas_str = input(&#34;Gerar estatísticas dos documentos? (S/N): &#34;)
                organizar_em_pastas_str = input(&#34;Organizar os documentos em pastas separadas? (S/N): &#34;)
                retirar_sentencas_similares_str = input(&#34;Deseja retirar as sentenças similares na geração dos &#34;
                                                        &#34;datasets? (S/N): &#34;)
                if retirar_sentencas_similares_str.lower() == &#39;s&#39;:
                    escopo_global_sentencas_str = input(&#34;Considerar o escopo global dos documentos para retirada das &#34;
                                                        &#34;sentenças? (S/N): &#34;)

            reprocessar_str = input(&#34;Reprocessar? (S/N): &#34;)

            resp_stat = gerar_estatisticas_str.lower()
            resp_organizar = organizar_em_pastas_str.lower()
            resp_reproc = reprocessar_str.lower()
            resp_retirar_sentencas_similares = retirar_sentencas_similares_str.lower()
            resp_escopo_global_sentencas = escopo_global_sentencas_str.lower()

            if resp_stat == &#39;s&#39;:
                gerar_estatisticas = True
            elif resp_stat == &#39;n&#39;:
                gerar_estatisticas = False
            else:
                print(&#34;\nParâmetro &#39;Gerar estatísticas&#39; incorreto. Escolha (S ou N).&#34;)

            if resp_organizar == &#39;s&#39;:
                organizar_em_pastas = True
            elif resp_organizar == &#39;n&#39;:
                organizar_em_pastas = False
            else:
                print(&#34;\nParâmetro &#39;organizar_em_pastas&#39; incorreto. Escolha (S ou N).&#34;)

            if resp_retirar_sentencas_similares == &#39;s&#39;:
                retirar_sentencas_similares = True
            elif resp_retirar_sentencas_similares == &#39;n&#39;:
                retirar_sentencas_similares = False
            else:
                print(&#34;\nParâmetro &#39;Retirar sentenças semelhantes&#39; incorreto. Escolha (S ou N).&#34;)

            if resp_escopo_global_sentencas == &#39;s&#39;:
                escopo_global_sentencas = True
            elif resp_escopo_global_sentencas == &#39;n&#39;:
                escopo_global_sentencas = False
            else:
                print(&#34;\nParâmetro &#39;Escopo global das sentenças&#39; incorreto. Escolha (S ou N).&#34;)

            if resp_reproc == &#39;s&#39;:
                reprocessar = True
            elif resp_reproc == &#39;n&#39;:
                reprocessar = False
            else:
                print(&#34;\nParâmetro &#39;Reprocessar&#39; incorreto. Escolha (S ou N).&#34;)

            if (resp_reproc == &#39;s&#39; or resp_reproc == &#39;n&#39;) and (resp_stat == &#39;s&#39; or resp_stat == &#39;n&#39;) and \
                    (resp_organizar == &#39;s&#39; or resp_organizar == &#39;n&#39;) and \
                    (resp_retirar_sentencas_similares == &#39;s&#39; or resp_retirar_sentencas_similares == &#39;n&#39;) and \
                    (resp_escopo_global_sentencas == &#39;s&#39; or resp_escopo_global_sentencas == &#39;n&#39;):
                ren(codproc, qtd_sents, reprocessar, gerar_estatisticas, organizar_em_pastas,
                    retirar_sentencas_similares, escopo_global_sentencas)
        elif op == &#39;5&#39;:
            retirar_sentencas_similares_str = input(&#34;\nDeseja retirar as sentenças similares na geração dos arquivos &#34;
                                                    &#34;CONLL? (S/N): &#34;)
            resp_retirar_sentencas_similares = retirar_sentencas_similares_str.lower()

            if resp_retirar_sentencas_similares == &#39;s&#39;:
                retirar_sentencas_similares = True
            elif resp_retirar_sentencas_similares == &#39;n&#39;:
                retirar_sentencas_similares = False
            else:
                print(&#34;\nParâmetro &#39;Retirar sentenças semelhantes&#39; incorreto. Escolha (S ou N).&#34;)
                continue

            dividir_dataset_str = input(&#34;Deseja dividir o dataset em treino, teste e validação? (S/N): &#34;)
            resp_dividir_dataset_str = dividir_dataset_str.lower()

            if resp_dividir_dataset_str == &#39;s&#39;:
                try:
                    tamanho_dataset_teste = float(input(&#34;Digite o tamanho do dataset de teste (tem que ser um número &#34;
                                                        &#34;decimal maior que 0.0 e menor que 1.0): &#34;))
                except ValueError:
                    print(&#34;\nValor incorreto. Digite um número decimal!&#34;)
                    continue

                if tamanho_dataset_teste &lt;= 0.0 or tamanho_dataset_teste &gt;= 1.0:
                    print(&#34;\nValor incorreto. Digite um número decimal maior que 0.0 e menor que 1.0!&#34;)
                    continue
            elif resp_dividir_dataset_str == &#39;n&#39;:
                tamanho_dataset_teste = 0.0
            else:
                print(&#34;\nParâmetro &#39;Dividir dataset&#39; incorreto. Escolha (S ou N).&#34;)
                continue

            if resp_retirar_sentencas_similares == &#39;s&#39; or resp_retirar_sentencas_similares == &#39;n&#39;:
                converter_jsonl_conll(retirar_sentencas_semelhantes=retirar_sentencas_similares,
                                      escopo_global_sentencas=True, tamanho_dataset_teste=tamanho_dataset_teste,
                                      concatenar_arquivos=True)
        elif op.upper() == &#39;0&#39;:
            break


# Obs.: para rodar este script diretamente no caminho dele, tem que configurar a variável PYTHONPATH com o caminho do
# projeto. Exemplo no Linux: export PYTHONPATH=&#39;/dados/develop/PycharmProjects/mestrado&#39;
if __name__ == &#34;__main__&#34;:
    menu()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="interface_prog.cadastrar_arquivos"><code class="name flex">
<span>def <span class="ident">cadastrar_arquivos</span></span>(<span>tipo, usuario, caminho_entrada)</span>
</code></dt>
<dd>
<div class="desc"><p>Faz o cadastro dos arquivos</p>
<pre><code>@param tipo: Tipo do arquivo (EDITAL, etc.)
@param usuario: Usuário que está realizando o cadastro
@param caminho_entrada: Caminho onde os documentos no formato PDF se encontram
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cadastrar_arquivos(tipo, usuario, caminho_entrada):
    &#34;&#34;&#34;
        Faz o cadastro dos arquivos

            @param tipo: Tipo do arquivo (EDITAL, etc.)
            @param usuario: Usuário que está realizando o cadastro
            @param caminho_entrada: Caminho onde os documentos no formato PDF se encontram
    &#34;&#34;&#34;
    caminho = None

    if tipo == &#39;EDITAL&#39;:
        caminho = os.path.join(caminho_entrada, &#39;editais&#39;)

    arquivos_cadastrar = []

    # Obtém a lista de todos os arquivos que serão cadastrados
    try:
        arquivos_cadastrar = os.listdir(caminho)
    except FileNotFoundError:
        print(f&#34;\nO caminho &#39;{caminho}&#39; não existe!\n&#34;)
        exit(FILE_NOT_FOUND_ERROR)
    except PermissionError:
        print(f&#34;\nErro ao listar o caminho &#39;{caminho}&#39;. Permissão de leitura negada!\n&#34;)
        exit(PERMISSION_ERROR)

    arquivos_cadastrar.sort()

    if &#39;preproc.lock&#39; not in arquivos_cadastrar:
        qtd_arquivos_cadastrados = 0
        print(&#34;\n=&gt; Arquivos cadastrados:\n&#34;)

        for a in arquivos_cadastrar:
            if &#39;.metadados&#39; not in a and a + &#39;.metadados&#39; not in arquivos_cadastrar and a != &#39;erro&#39;:
                print(f&#34;   {a}&#34;)
                qtd_arquivos_cadastrados += 1
                preparar_arquivo(caminho, a, &#34;n/a&#34;, usuario, gerar_epoch())

        print(f&#34;\nQuantidade de arquivos cadastrados: {qtd_arquivos_cadastrados}&#34;)
    else:
        print(f&#34;\nERRO: A pasta &#39;{caminho_entrada}&#39; está bloqueada pela rotina de pre-processamento. Aguarde a rotina &#34;
              f&#34;terminar e tente novamente!&#34;)</code></pre>
</details>
</dd>
<dt id="interface_prog.imprimir_chaves"><code class="name flex">
<span>def <span class="ident">imprimir_chaves</span></span>(<span>tipo_doc)</span>
</code></dt>
<dd>
<div class="desc"><p>Imprime as chaves correspondentes à cada tipo de documento</p>
<pre><code>@param tipo_doc: Tipo do documento para imprimir as chaves correspondentes
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def imprimir_chaves(tipo_doc):
    &#34;&#34;&#34;
    Imprime as chaves correspondentes à cada tipo de documento

        @param tipo_doc: Tipo do documento para imprimir as chaves correspondentes
    &#34;&#34;&#34;
    print(
        &#34;&#34;&#34;
        ----&gt; Chaves para pesquisa &lt;----

        Escolha uma chave, copie e cole no campo &#34;Chave&#34;.
    &#34;&#34;&#34;)

    tipo = tipo_doc.upper()

    if tipo == &#34;EDITAL&#34;:
        print(
            &#34;&#34;&#34;
            ## Edital:
                Edital__nome
                Edital__codigo_arq
                Edital__codigo_lote
                Edital__dumpconteudo
                Edital__secoes.Secao__numero
                Edital__secoes.Secao__titulo
                Edital__secoes.Secao__subsecoes.Subsecao__numero
                Edital__secoes.Secao__subsecoes.Subsecao__descricao
                &#34;&#34;&#34;)
    elif tipo == &#34;DOCUMENTO&#34;:
        print(
            &#34;&#34;&#34;
            ## Documento:
                Documento__nome
                Documento__codigo_arq
                Documento__hash_md5
                Documento__tipo_arq
                Documento__extensao
                Documento__data_cadastro
                Documento__usuario_cadastrou
                Documento__cod_processamento
                Documento__codigo_lote
                Documento__nome_arq_original
                Documento__url_web
                Documento__caminho_base
                Documento__caminho_relativo
                Documento__head
                &#34;&#34;&#34;)
    elif tipo == &#34;LOTE&#34;:
        print(
            &#34;&#34;&#34;
            ## Lote:
                Lote__codigo_lote
                Lote__tipo
                Lote__tempo_inicio
                Lote__tempo_fim
                Lote__documentos_ok
                Lote__documentos_erro
                &#34;&#34;&#34;)
    elif tipo == &#34;RESULTADO&#34;:
        print(
            &#34;&#34;&#34;
            ## Resultado:
                Resultado__tipo
                Resultado__codigo_lote
                Resultado__data_resultado
                Resultado__status
                Resultado__nome_arq_original
                Resultado__tipo_arq
                Resultado__codigo_arq
                Resultado__url_web
                Resultado__usuario_cadastrou
                Resultado__data_cadastro
                Resultado__mensagens
            &#34;&#34;&#34;
        )</code></pre>
</details>
</dd>
<dt id="interface_prog.imprimir_documento"><code class="name flex">
<span>def <span class="ident">imprimir_documento</span></span>(<span>doc_obj, mensagem)</span>
</code></dt>
<dd>
<div class="desc"><p>Imprime um documento</p>
<pre><code>@param doc_obj: Documento que será impresso
@param mensagem: Mensagem referente ao documento que será impresso
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def imprimir_documento(doc_obj, mensagem):
    &#34;&#34;&#34;
    Imprime um documento

        @param doc_obj: Documento que será impresso
        @param mensagem: Mensagem referente ao documento que será impresso
    &#34;&#34;&#34;
    print(mensagem)
    print(len(mensagem) * &#39;-&#39;, end=&#39;&#39;)
    print(&#39;\n&#39;)

    if &#39;EDITAL&#39; in mensagem:
        print(f&#39; &gt; Nome do documento.....: {doc_obj.nome}\n&#39;)
        print(f&#39; &gt; Código do arquivo.....: {doc_obj.codigo_arq}\n&#39;)
        print(f&#39; &gt; Código do lote........: {doc_obj.codigo_lote}\n&#39;)
        print(f&#39; &gt; Dump do conteúdo......:\n&#39;)
        for n, p in enumerate(doc_obj.dumpconteudo):
            print(f&#34;  - Pag. {n+1}: {p}&#34;)

        for s in doc_obj.secoes:
            print(f&#39;\n# Seção: {s.numero} - Pág(s) {s.paginas}: {s.titulo}&#39;)

            for sb in s.subsecoes:
                print(f&#39;{sb.numero}: {sb.descricao}&#39;)
    elif &#39;DOCUMENTO&#39; in mensagem:
        print(f&#34;Nome do arquivo...........: {doc_obj.nome}&#34;)
        print(f&#34;Código do arquivo.........: {doc_obj.codigo_arq}&#34;)
        print(f&#34;Hash MD5..................: {doc_obj.hash_md5}&#34;)
        print(f&#34;Tipo......................: {doc_obj.tipo_arq}&#34;)
        print(f&#34;Extensao..................: {doc_obj.extensao}&#34;)
        print(f&#34;Data Cadastro epoch.......: {doc_obj.data_cadastro}, tipo: {type(doc_obj.data_cadastro)}&#34;)
        print(f&#34;Data Cadastro normal......: {gerar_data(doc_obj.data_cadastro, &#39;%d/%m/%Y %H:%M:%Shs&#39;)}&#34;)
        print(f&#34;Usuário que cadastrou.....: {doc_obj.usuario_cadastrou}&#34;)
        print(f&#34;Código Processamento......: {doc_obj.cod_processamento}&#34;)
        print(f&#34;Lote......................: {doc_obj.codigo_lote}&#34;)
        print(f&#34;Nome do arquivo original..: {doc_obj.nome_arq_original}&#34;)
        print(f&#34;URL WEB...................: {doc_obj.url_web}&#34;)
        print(f&#34;Caminho Base..............: {doc_obj.caminho_base}&#34;)
        print(f&#34;Caminho Relativo..........: {doc_obj.caminho_relativo}&#34;)
        print(f&#34;Head......................: {len(doc_obj.head)} páginas&#34;)
        for p, h in enumerate(doc_obj.head):
            print(f&#34;  - Pag. {p+1}: {h}&#34;)
    elif &#39;LOTE&#39; in mensagem:
        print(f&#34;codigo....................: {doc_obj.codigo_lote}&#34;)
        print(f&#34;tipo......................: {doc_obj.tipo}&#34;)
        print(f&#34;tempo_inicio..............: {doc_obj.tempo_inicio}&#34;)
        print(f&#34;tempo_fim.................: {doc_obj.tempo_fim}&#34;)
        print(f&#34;documentos_ok.............: {doc_obj.documentos_ok}&#34;)
        print(f&#34;documentos_erro...........: {doc_obj.documentos_erro}&#34;)
        print(f&#34;Estatísticas..............: {doc_obj.obter_estatisticas()}&#34;)
    elif &#39;RESULTADO&#39; in mensagem:
        print(f&#34;Tipo do resultado.........: {doc_obj.tipo}&#34;)
        print(f&#34;Código do lote............: {doc_obj.codigo_lote}&#34;)
        print(f&#34;Data epoch................: {doc_obj.data_resultado}, tipo: {type(doc_obj.data_resultado)}&#34;)
        print(f&#34;Data normal...............: {gerar_data(doc_obj.data_resultado, &#39;%d/%m/%Y %H:%M:%Shs&#39;)}&#34;)
        print(f&#34;Status....................: {doc_obj.status}&#34;)
        print(f&#34;Nome do arquivo original..: {doc_obj.nome_arq_original}&#34;)
        print(f&#34;Tipo......................: {doc_obj.tipo_arq}&#34;)
        print(f&#34;Código do arquivo.........: {doc_obj.codigo_arq}&#34;)
        print(f&#34;URL WEB...................: {doc_obj.url_web}&#34;)
        print(f&#34;Usuário que cadastrou.....: {doc_obj.usuario_cadastrou}&#34;)
        print(f&#34;Data Cadastro normal......: {gerar_data(doc_obj.data_cadastro, &#39;%d/%m/%Y %H:%M:%Shs&#39;)}&#34;)
        print(f&#34;Mensagens.................: {len(doc_obj.mensagens)} mensagens&#34;)
        for n, m in enumerate(doc_obj.mensagens):
            print(f&#34;  - Msg. {n+1}: {m}&#34;)</code></pre>
</details>
</dd>
<dt id="interface_prog.ler_dados_bd"><code class="name flex">
<span>def <span class="ident">ler_dados_bd</span></span>(<span>tipo, opcao, chave, valor, caminho_dump)</span>
</code></dt>
<dd>
<div class="desc"><p>Ler os documentos no banco de dados</p>
<pre><code>@param tipo: Tipo do documento
@param opcao: Opção de base de dados capturada do menu principal
@param chave: Chave para a busca do documento
@param valor: Valor da chave para busca do documento
@param caminho_dump: Caminho para geração do dump do edital, caso seja necessário
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ler_dados_bd(tipo, opcao, chave, valor, caminho_dump):
    &#34;&#34;&#34;
    Ler os documentos no banco de dados

        @param tipo: Tipo do documento
        @param opcao: Opção de base de dados capturada do menu principal
        @param chave: Chave para a busca do documento
        @param valor: Valor da chave para busca do documento
        @param caminho_dump: Caminho para geração do dump do edital, caso seja necessário
    &#34;&#34;&#34;
    docs_json = None

    if tipo == &#39;EDITAL&#39;:
        banco_mongo = &#39;db_documentos&#39;
        colecao_mongo = &#39;col_editais&#39;

        if opcao == &#39;3&#39;:
            c_mongo = ClienteGenerico(&#39;MongoDB&#39;, &#39;localhost&#39;, 2717, banco_mongo)
            doc_mongo_js = c_mongo.buscar_todos(colecao_mongo, chave, valor)
            c_mongo.fechar_conexao()
            docs_json = list(doc_mongo_js)
    elif tipo == &#39;DOCUMENTO&#39;:
        c_mongo_meta = ClienteGenerico(&#39;MongoDB&#39;, &#39;localhost&#39;, 2717, &#39;db_metadados&#39;)
        doc_metadados_js = c_mongo_meta.buscar_todos(&#39;col_metadados_docs&#39;, chave, valor)
        c_mongo_meta.fechar_conexao()
        docs_json = list(doc_metadados_js)
    elif tipo == &#39;LOTE&#39;:
        c_mongo_lote = ClienteGenerico(&#39;MongoDB&#39;, &#39;localhost&#39;, 2717, &#39;db_metadados&#39;)
        doc_lotes_js = c_mongo_lote.buscar_todos(&#39;col_metadados_lotes&#39;, chave, valor)
        c_mongo_lote.fechar_conexao()
        docs_json = list(doc_lotes_js)
    elif tipo == &#39;RESULTADO&#39;:
        c_mongo_resultado = ClienteGenerico(&#39;MongoDB&#39;, &#39;localhost&#39;, 2717, &#39;db_metadados&#39;)
        doc_resultados_js = c_mongo_resultado.buscar_todos(&#39;col_metadados_resultados&#39;, chave, valor)
        c_mongo_resultado.fechar_conexao()
        docs_json = list(doc_resultados_js)
    else:
        print(f&#34;\nO tipo de documento &#39;{tipo}&#39; não está cadastrado!&#34;)
        return

    listar_documentos_impressao(tipo, docs_json, caminho_dump)</code></pre>
</details>
</dd>
<dt id="interface_prog.listar_documentos_impressao"><code class="name flex">
<span>def <span class="ident">listar_documentos_impressao</span></span>(<span>tipo, docs_json, caminho_dump)</span>
</code></dt>
<dd>
<div class="desc"><p>Lista os documentos que poderão ser impressos</p>
<pre><code>@param tipo: Tipo do documento
@param docs_json: Documento canditato à impressão
@param caminho_dump: Caminho para geração do dump do edital, caso seja necessário
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def listar_documentos_impressao(tipo, docs_json, caminho_dump):
    &#34;&#34;&#34;
    Lista os documentos que poderão ser impressos

        @param tipo: Tipo do documento
        @param docs_json: Documento canditato à impressão
        @param caminho_dump: Caminho para geração do dump do edital, caso seja necessário
    &#34;&#34;&#34;
    seq = 0
    tam = len(list(docs_json))
    ler_doc = True
    objeto_desserializado = None
    print(f&#34;\n    ## Qtd de documentos retornados: {tam}&#34;)

    while seq &lt; tam:
        if ler_doc:
            objeto_desserializado = desserializar(docs_json[seq])
            ler_doc = False  # Só voltará ser &#39;True&#39; se a opção escolhida for válida
            seq += 1

        print(f&#34;\n    &gt;&gt; Doc. {seq}/{tam}&#34;)

        if tipo == &#39;EDITAL&#39; or tipo == &#39;DOCUMENTO&#39;:
            print(f&#34;        -&gt; Nome do documento: {objeto_desserializado.codigo_arq}&#34;)
        elif tipo == &#39;LOTE&#39;:
            print(f&#34;        -&gt; Código do lote: {objeto_desserializado.codigo}&#34;)
        elif tipo == &#39;RESULTADO&#39;:
            print(f&#34;        -&gt; Tipo do resultado: {objeto_desserializado.tipo}&#34;)

        r = input(&#34;   \n           Deseja imprimir (S=Sim / N=Não / V=Navegar / X=Sair)?: &#34;).upper()

        if r == &#39;S&#39;:
            if tipo == &#39;EDITAL&#39;:
                ri = input(&#34;   \n           Imprimir onde (T=Tela / A=Arquivo)?: &#34;).upper()

                if ri == &#39;T&#39;:
                    imprimir_documento(objeto_desserializado, f&#34;\n\n ** Dados extraídos - {tipo} **&#34;)
                    ler_doc = True
                elif ri == &#39;A&#39;:
                    tipo_dump = &#34;&#34;

                    print(
                        &#34;&#34;&#34;
                        &gt; Tipos de dump:\n
                          EDITAL - Edital completo com as seções separadas
                          SECOES - Somenteas seções do edital
                          CONTEUDO - Edital completo sem as seções separadas
                          TODOS - Faz o dump de todos os tipos
                        &#34;&#34;&#34;
                    )

                    while tipo_dump not in [&#39;EDITAL&#39;, &#39;SECOES&#39;, &#39;CONTEUDO&#39;, &#39;TODOS&#39;, &#39;X&#39;]:
                        tipo_dump = input(&#34;           Escolha um tipo (X=Sair): &#34;).upper()

                    if tipo_dump != &#39;X&#39;:
                        if tipo_dump != &#39;TODOS&#39;:
                            lst_tipo_dump = [tipo_dump]
                        else:
                            lst_tipo_dump = [&#39;EDITAL&#39;, &#39;SECOES&#39;, &#39;CONTEUDO&#39;]

                        for t in lst_tipo_dump:
                            nome_arquivo = os.path.join(caminho_dump, objeto_desserializado.codigo_arq.split(&#39;.&#39;)[0] +
                                                        &#39;_&#39; + t + &#39;.txt&#39;)

                            descarregar_conteudo(objeto_desserializado, t, nome_arquivo)
                            print(f&#34;\n           Salvo como &#39;{nome_arquivo}&#39;&#34;)

                        ler_doc = True
                else:
                    print(&#34;\n           Opção inválida!&#34;)
            else:
                imprimir_documento(objeto_desserializado, f&#34;\n\n ** Dados extraídos - {tipo} **&#34;)
                ler_doc = True
        elif r == &#39;N&#39;:
            ler_doc = True
        elif r == &#39;V&#39;:
            while True:
                ri = input(f&#34;\n        - Digite o no. do documento (1-{tam} / 0=Voltar): &#34;)

                try:
                    n = int(ri)
                except ValueError:
                    print(&#34;\n          Digite um número!&#34;)
                    continue

                if 1 &lt;= n &lt;= tam:
                    seq = n - 1
                    ler_doc = True
                    break
                elif n == 0:
                    break
                else:
                    print(f&#34;\n          O número digitado está fora da faixa (1 a {tam})!&#34;)
        elif r == &#39;X&#39;:
            break
        else:
            print(&#34;\n       Opção incorreta!&#34;)

    if tam &gt; 0 and (seq == tam):
        print(&#34;\n       *** Fim da lista! ***&#34;)</code></pre>
</details>
</dd>
<dt id="interface_prog.menu"><code class="name flex">
<span>def <span class="ident">menu</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Menu principal do sistema</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def menu():
    &#34;&#34;&#34;
    Menu principal do sistema
    &#34;&#34;&#34;
    # Obtém o caminho do arquivo de configuração para montar o caminho completo
    caminho_arquivo_configuracao = PREPROC_CAMINHO_ARQ_CONF
    nome_arquivo_configuracao = &#39;param_preproc.conf&#39;
    arq_conf = os.path.join(caminho_arquivo_configuracao, nome_arquivo_configuracao)

    conf = inicializar_parametros(&#39;preproc&#39;, arq_conf)

    # Obtém alguns parâmetros de configuração do módulo
    parametros = {&#39;caminho_arq_conf&#39;: arq_conf,
                  &#39;p_caminho_entrada&#39;: conf.obter_valor_parametro(&#39;p_caminho_entrada&#39;),
                  &#39;p_caminho_dumps&#39;: conf.obter_valor_parametro(&#39;p_caminho_dumps&#39;)}

    validar_pastas(parametros)

    while True:
        print(&#39;\n***************( INTERFACE DO PROTÓTIPO - MODO TEXTO )**************\n&#39;)
        print(&#39;                      &gt;&gt; MENU &lt;&lt;\n&#39;)
        print(&#39;             1 - Cadastrar editais&#39;)
        print(&#39;             2 - Pré-Processar&#39;)
        print(&#39;             3 - Buscar editais (MongoDB)&#39;)
        print(&#39;             4 - Construir Dataset&#39;)
        print(&#39;             5 - Converter JSONL para CONLL&#39;)
        print(&#39;\n********************************************************************&#39;)
        op = input(&#34;Escolha a opção (Sair =&gt; 0): &#34;)

        if op == &#39;1&#39;:
            cadastrar_arquivos(&#39;EDITAL&#39;, &#39;SISTEMA&#39;, parametros[&#39;p_caminho_entrada&#39;])
        elif op == &#39;2&#39;:
            pre_processamento()
        elif op == &#39;3&#39;:
            print(&#34;\nInforme os parâmetros abaixo:\n&#34;)
            tipo_doc = input(&#34;  --Tipo (EDITAL, DOCUMENTO, LOTE ou RESULTADO)...: &#34;).upper()

            while tipo_doc not in [&#34;EDITAL&#34;, &#34;DOCUMENTO&#34;, &#34;LOTE&#34;, &#34;RESULTADO&#34;, &#34;X&#34;]:
                print(f&#34;\n     O tipo de documento &#39;{tipo_doc}&#39; não existe!\n&#34;)
                tipo_doc = input(&#34;  --Tipo (EDITAL, DOCUMENTO, LOTE ou RESULTADO) |  X=Sair...: &#34;).upper()

            if tipo_doc != &#39;X&#39;:
                chave_doc = &#39;*&#39;

                while chave_doc == &#39;*&#39;:
                    chave_doc = input(&#39;  --Chave (* = Listas as opções)..................: &#39;)

                    if chave_doc == &#39;*&#39;:
                        imprimir_chaves(tipo_doc)
                    else:
                        break

                while True:
                    print(f&#34;\n  ***  Pesquisando no &#39;MongoDB&#39; pela chave: &#39;{chave_doc}&#39;  ***\n&#34;)

                    valor_chave = input(&#39;    --Valor (X=Sair)..: &#39;)

                    if valor_chave.upper() == &#39;X&#39;:
                        break

                    ler_dados_bd(tipo_doc.upper(), op, chave_doc, valor_chave, parametros[&#39;p_caminho_dumps&#39;])
        elif op == &#39;4&#39;:
            gerar_estatisticas = False
            gerar_estatisticas_str = &#39;n&#39;
            organizar_em_pastas = True
            organizar_em_pastas_str = &#39;n&#39;
            qtd_sents = 0
            reprocessar = False
            retirar_sentencas_similares = False
            retirar_sentencas_similares_str = &#39;n&#39;
            escopo_global_sentencas = True
            escopo_global_sentencas_str = &#39;s&#39;

            codproc = input(&#34;\nDigite o código de processamento (ner, classificacao ou classificacao_label): &#34;)

            if codproc == &#39;ner&#39;:
                qtd_sents = int(input(&#34;Digite a quantidade de sentenças por arquivo: &#34;))
                gerar_estatisticas_str = input(&#34;Gerar estatísticas dos documentos? (S/N): &#34;)
                organizar_em_pastas_str = input(&#34;Organizar os documentos em pastas separadas? (S/N): &#34;)
                retirar_sentencas_similares_str = input(&#34;Deseja retirar as sentenças similares na geração dos &#34;
                                                        &#34;datasets? (S/N): &#34;)
                if retirar_sentencas_similares_str.lower() == &#39;s&#39;:
                    escopo_global_sentencas_str = input(&#34;Considerar o escopo global dos documentos para retirada das &#34;
                                                        &#34;sentenças? (S/N): &#34;)

            reprocessar_str = input(&#34;Reprocessar? (S/N): &#34;)

            resp_stat = gerar_estatisticas_str.lower()
            resp_organizar = organizar_em_pastas_str.lower()
            resp_reproc = reprocessar_str.lower()
            resp_retirar_sentencas_similares = retirar_sentencas_similares_str.lower()
            resp_escopo_global_sentencas = escopo_global_sentencas_str.lower()

            if resp_stat == &#39;s&#39;:
                gerar_estatisticas = True
            elif resp_stat == &#39;n&#39;:
                gerar_estatisticas = False
            else:
                print(&#34;\nParâmetro &#39;Gerar estatísticas&#39; incorreto. Escolha (S ou N).&#34;)

            if resp_organizar == &#39;s&#39;:
                organizar_em_pastas = True
            elif resp_organizar == &#39;n&#39;:
                organizar_em_pastas = False
            else:
                print(&#34;\nParâmetro &#39;organizar_em_pastas&#39; incorreto. Escolha (S ou N).&#34;)

            if resp_retirar_sentencas_similares == &#39;s&#39;:
                retirar_sentencas_similares = True
            elif resp_retirar_sentencas_similares == &#39;n&#39;:
                retirar_sentencas_similares = False
            else:
                print(&#34;\nParâmetro &#39;Retirar sentenças semelhantes&#39; incorreto. Escolha (S ou N).&#34;)

            if resp_escopo_global_sentencas == &#39;s&#39;:
                escopo_global_sentencas = True
            elif resp_escopo_global_sentencas == &#39;n&#39;:
                escopo_global_sentencas = False
            else:
                print(&#34;\nParâmetro &#39;Escopo global das sentenças&#39; incorreto. Escolha (S ou N).&#34;)

            if resp_reproc == &#39;s&#39;:
                reprocessar = True
            elif resp_reproc == &#39;n&#39;:
                reprocessar = False
            else:
                print(&#34;\nParâmetro &#39;Reprocessar&#39; incorreto. Escolha (S ou N).&#34;)

            if (resp_reproc == &#39;s&#39; or resp_reproc == &#39;n&#39;) and (resp_stat == &#39;s&#39; or resp_stat == &#39;n&#39;) and \
                    (resp_organizar == &#39;s&#39; or resp_organizar == &#39;n&#39;) and \
                    (resp_retirar_sentencas_similares == &#39;s&#39; or resp_retirar_sentencas_similares == &#39;n&#39;) and \
                    (resp_escopo_global_sentencas == &#39;s&#39; or resp_escopo_global_sentencas == &#39;n&#39;):
                ren(codproc, qtd_sents, reprocessar, gerar_estatisticas, organizar_em_pastas,
                    retirar_sentencas_similares, escopo_global_sentencas)
        elif op == &#39;5&#39;:
            retirar_sentencas_similares_str = input(&#34;\nDeseja retirar as sentenças similares na geração dos arquivos &#34;
                                                    &#34;CONLL? (S/N): &#34;)
            resp_retirar_sentencas_similares = retirar_sentencas_similares_str.lower()

            if resp_retirar_sentencas_similares == &#39;s&#39;:
                retirar_sentencas_similares = True
            elif resp_retirar_sentencas_similares == &#39;n&#39;:
                retirar_sentencas_similares = False
            else:
                print(&#34;\nParâmetro &#39;Retirar sentenças semelhantes&#39; incorreto. Escolha (S ou N).&#34;)
                continue

            dividir_dataset_str = input(&#34;Deseja dividir o dataset em treino, teste e validação? (S/N): &#34;)
            resp_dividir_dataset_str = dividir_dataset_str.lower()

            if resp_dividir_dataset_str == &#39;s&#39;:
                try:
                    tamanho_dataset_teste = float(input(&#34;Digite o tamanho do dataset de teste (tem que ser um número &#34;
                                                        &#34;decimal maior que 0.0 e menor que 1.0): &#34;))
                except ValueError:
                    print(&#34;\nValor incorreto. Digite um número decimal!&#34;)
                    continue

                if tamanho_dataset_teste &lt;= 0.0 or tamanho_dataset_teste &gt;= 1.0:
                    print(&#34;\nValor incorreto. Digite um número decimal maior que 0.0 e menor que 1.0!&#34;)
                    continue
            elif resp_dividir_dataset_str == &#39;n&#39;:
                tamanho_dataset_teste = 0.0
            else:
                print(&#34;\nParâmetro &#39;Dividir dataset&#39; incorreto. Escolha (S ou N).&#34;)
                continue

            if resp_retirar_sentencas_similares == &#39;s&#39; or resp_retirar_sentencas_similares == &#39;n&#39;:
                converter_jsonl_conll(retirar_sentencas_semelhantes=retirar_sentencas_similares,
                                      escopo_global_sentencas=True, tamanho_dataset_teste=tamanho_dataset_teste,
                                      concatenar_arquivos=True)
        elif op.upper() == &#39;0&#39;:
            break</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="interface_prog.cadastrar_arquivos" href="#interface_prog.cadastrar_arquivos">cadastrar_arquivos</a></code></li>
<li><code><a title="interface_prog.imprimir_chaves" href="#interface_prog.imprimir_chaves">imprimir_chaves</a></code></li>
<li><code><a title="interface_prog.imprimir_documento" href="#interface_prog.imprimir_documento">imprimir_documento</a></code></li>
<li><code><a title="interface_prog.ler_dados_bd" href="#interface_prog.ler_dados_bd">ler_dados_bd</a></code></li>
<li><code><a title="interface_prog.listar_documentos_impressao" href="#interface_prog.listar_documentos_impressao">listar_documentos_impressao</a></code></li>
<li><code><a title="interface_prog.menu" href="#interface_prog.menu">menu</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>